

디자인 시스템에서 컴포넌트를 체계적으로 분류하는 것은 일관성 있는 개발과 효율적인 협업을 위해 중요합니다. 이 문서에서는 Lumir Design System에서 채택한 **Primitives**(프리미티브), **Compounds**(컴파운드), **Patterns**(패턴)의 세 가지 계층 구조에 대한 명확한 정의, 구분 기준 및 실제 예시를 제공합니다.

## 1. 컴포넌트 계층 정의

### 1.1 Primitives (프리미티브 컴포넌트)

**정의**: 더 이상 분해할 수 없는 기본 UI 빌딩 블록으로, 단일 책임을 가지며 다른 LDS 컴포넌트에 의존하지 않는 독립적인 요소입니다.

**핵심 특성**:
- 자족성: 다른 LDS 컴포넌트를 가져오지(import) 않음
- 원자성: 더 작은 컴포넌트로 분해할 수 없음
- 단일 책임: 명확히 정의된 하나의 기능 또는 목적
- 맥락 독립성: 어떤 상황에서도 동일하게 작동

### 1.2 Compounds (컴파운드 컴포넌트)

**정의**: 두 개 이상의 프리미티브 컴포넌트를 조합하여 만든 UI 요소로, 일관된 상호작용 패턴과 내부 상태 관리를 제공하는 자체 포함된(self-contained) 컴포넌트입니다.

**핵심 특성**:
- 합성성: 프리미티브 컴포넌트들의 조합으로 구성
- 내부 로직: 구성 요소 간 상호작용 관리
- 독립적 기능: 단일 UI 패턴으로 일관되게 작동
- 맥락 독립성: 비즈니스 로직이나 특정 도메인 지식에 의존하지 않음

### 1.3 Patterns (패턴 컴포넌트)

**정의**: 특정 사용자 문제나 비즈니스 요구를 해결하기 위해 설계된 복합적인 UI 솔루션으로, 여러 컴파운드와 프리미티브 컴포넌트를 결합하여 특정 맥락에서 작동하도록 최적화된 컴포넌트입니다.

**핵심 특성**:
- 문제 해결 중심: 특정 사용자 문제나 비즈니스 요구 해결에 초점
- 복합 기능: 여러 상호작용과 기능을 조합
- 맥락 의존성: 특정 워크플로우나 비즈니스 로직과 통합
- 높은 복잡성: 복잡한 상태 관리와 데이터 흐름 포함

## 2. 명확한 구분 기준

다음 결정 기준을 사용하여, 주어진 컴포넌트가 어느 계층에 속하는지 체계적으로 판단할 수 있습니다.

### 2.1 프리미티브 판별 기준

컴포넌트가 다음 **모든** 질문에 "예"로 답할 수 있다면 프리미티브입니다:

1. **독립성 테스트**: 이 컴포넌트는 다른 LDS 컴포넌트를 import하지 않고 독립적으로 구현되었는가?
2. **원자성 테스트**: 이 컴포넌트는 더 작은 의미 있는 UI 컴포넌트로 분해할 수 없는가?
3. **단일 책임 테스트**: 이 컴포넌트는 정확히 한 가지 핵심 기능이나 목적을 가지고 있는가?
4. **기본 HTML 근접성 테스트**: 이 컴포넌트는 기본 HTML 요소를 직접 확장하거나 대체하는가?

### 2.2 컴파운드 판별 기준

컴포넌트가 다음 기준을 **모두** 충족하면 컴파운드입니다:

1. **구성 테스트**: 이 컴포넌트는 두 개 이상의 프리미티브 컴포넌트로 구성되어 있는가?
2. **내부 상태 관리 테스트**: 이 컴포넌트는 자체적인 내부 상태(열림/닫힘, 활성/비활성 등)를 관리하는가?
3. **범용성 테스트**: 이 컴포넌트는 도메인에 관계없이 다양한 맥락에서 일관되게 사용할 수 있는가?
4. **비즈니스 로직 독립성 테스트**: 이 컴포넌트는 특정 비즈니스 로직이나 도메인 지식에 의존하지 않는가?

### 2.3 패턴 판별 기준

컴포넌트가 다음 기준 중 **하나 이상**을 충족하면 패턴일 가능성이 높습니다:

1. **비즈니스 로직 테스트**: 이 컴포넌트는 특정 비즈니스 로직이나 도메인 지식을 포함하고 있는가?
2. **사용자 작업 테스트**: 이 컴포넌트는 특정 사용자 작업이나 목표를 완료하기 위해 설계되었는가?
3. **복합 상태 관리 테스트**: 이 컴포넌트는 여러 단계나 복잡한 상태 흐름을 관리하는가?
4. **데이터 의존성 테스트**: 이 컴포넌트는 특정 데이터 구조나 API에 의존하는가?
5. **맥락 특화 테스트**: 이 컴포넌트는 특정 맥락이나 사용 사례에 최적화되어 있는가?

## 3. 결정 트리

다음 결정 트리는 컴포넌트 분류 과정을 단계별로 안내합니다:

```
1. 다른 LDS 컴포넌트를 import하지 않는가?
   ├── 예: 더 작은 의미 있는 UI 컴포넌트로 분해할 수 없는가?
   │    ├── 예: 단일 기능이나 목적만 수행하는가?
   │    │    ├── 예: => 프리미티브 컴포넌트
   │    │    └── 아니오: => 컴파운드 컴포넌트 검토
   │    └── 아니오: => 컴파운드 컴포넌트 검토
   └── 아니오: 특정 비즈니스 로직이나 도메인 지식을 포함하는가?
        ├── 예: => 패턴 컴포넌트
        └── 아니오: 여러 컴포넌트 조합으로 단일 기능 단위를 형성하는가?
             ├── 예: => 컴파운드 컴포넌트
             └── 아니오: => 패턴 컴포넌트 검토
```

## 4. 컴포넌트 분류 매트릭스

다음 매트릭스는 주요 특성에 따른 컴포넌트 분류를 시각화합니다:

| 특성                | 프리미티브       | 컴파운드         | 패턴             |
|--------------------|----------------|-----------------|------------------|
| 다른 LDS 컴포넌트 사용 | ❌ 없음         | ✅ 프리미티브만    | ✅ 프리미티브와 컴파운드 |
| 기능 범위           | 단일 기능        | 단일 UI 패턴      | 복합 사용자 작업    |
| 상태 관리 복잡성     | 낮음 (자체 상태)  | 중간 (내부 상호작용) | 높음 (워크플로우)   |
| 맥락 독립성         | 완전 독립적      | 대부분 독립적      | 맥락 특화          |
| 비즈니스 로직       | ❌ 없음         | ❌ 최소한         | ✅ 포함됨         |
| 재사용 범위         | 모든 상황        | 다양한 상황       | 특정 상황          |

## 5. 컴포넌트 계층별 예시

### 5.1 프리미티브 컴포넌트 예시

다음 컴포넌트들은 명확한 프리미티브 컴포넌트입니다:

1. **Button**: 클릭 가능한 단일 상호작용 요소
   - 다른 LDS 컴포넌트를 가져오지 않음
   - 더 작은 유의미한 UI 요소로 분해할 수 없음
   - 사용자 클릭 액션을 처리하는 단일 책임

2. **Input**: 텍스트 입력을 위한 단일 폼 요소
   - HTML input 요소를 직접 확장
   - 텍스트 입력이라는 단일 기능
   - 다른 LDS 컴포넌트에 의존하지 않음

3. **Icon**: 시각적 아이콘을 표시하는 단일 요소
   - SVG를 렌더링하는 단일 책임
   - 독립적으로 사용 가능
   - 다른 LDS 컴포넌트를 import하지 않음

4. **Checkbox**: 상태 토글을 위한 단일 폼 요소
   - 체크 상태를 관리하는 단일 책임
   - HTML input[type=checkbox]를 확장
   - 독립적으로 구현됨

5. **Text/Typography**: 텍스트 스타일을 적용하는 단일 요소
   - 텍스트 표시라는 단일 기능
   - 다른 LDS 컴포넌트를 가져오지 않음
   - 더 작은 컴포넌트로 분해할 수 없음

### 5.2 컴파운드 컴포넌트 예시

다음 컴포넌트들은 명확한 컴파운드 컴포넌트입니다:

1. **Dropdown**: 옵션 선택을 위한 UI 요소
   - Button, Text, Icon, List 등 여러 프리미티브로 구성
   - 열림/닫힘 상태 관리 및 옵션 선택 로직 포함
   - 도메인에 관계없이 범용적으로 사용 가능
   - 비즈니스 로직에 의존하지 않음

2. **Modal/Dialog**: 오버레이 콘텐츠 표시
   - Backdrop, Container, Header, Button 등의 프리미티브로 구성
   - 열림/닫힘 상태 및 접근성 관리
   - 다양한 맥락에서 일관되게 사용 가능
   - 어떤 콘텐츠든 담을 수 있는 범용성

3. **Tabs**: 탭 인터페이스
   - TabList, Tab, TabPanel 등의 프리미티브로 구성
   - 활성 탭 상태 관리 및 탭 전환 로직
   - 범용적인 콘텐츠 구성 패턴
   - 비즈니스 로직 독립적

4. **Card**: 정보 컨테이너
   - Container, Header, Body, Footer 등의 프리미티브로 구성
   - 단일 관련 콘텐츠 그룹화
   - 어떤 콘텐츠든 담을 수 있는 범용성
   - 도메인 독립적

5. **Accordion**: 접이식 콘텐츠 패널
   - Header, Panel, Icon 등의 프리미티브로 구성
   - 열림/닫힘 상태 관리
   - 범용적인 콘텐츠 표시 패턴
   - 맥락 독립적

### 5.3 패턴 컴포넌트 예시

다음 컴포넌트들은 명확한 패턴 컴포넌트입니다:

1. **SignupForm**: 사용자 등록 플로우
   - Input, Button, Checkbox 등 여러 컴포넌트 조합
   - 유효성 검사, 서버 통신, 오류 처리 등 복잡한 로직
   - 사용자 등록이라는 특정 비즈니스 목표
   - 특정 API 및 데이터 모델에 의존

2. **DataTable with Filtering**: 데이터 필터링 및 표시
   - Table, Dropdown, Input, Pagination 등 조합
   - 정렬, 필터링, 페이지네이션 등 복잡한 데이터 처리
   - 특정 데이터 구조에 의존
   - 복잡한 사용자 상호작용 관리

3. **CheckoutFlow**: 결제 프로세스
   - 여러 단계의 양식, 결제 옵션, 확인 등 구성
   - 비즈니스 로직 (가격 계산, 세금, 배송 등)
   - 전자상거래 도메인 지식 필요
   - 복잡한 상태 관리 및 유효성 검사

4. **SearchInterface**: 고급 검색 기능
   - SearchBar, Filters, Results, Pagination 등 조합
   - 검색 알고리즘 및 필터 로직
   - 특정 데이터 모델 및 API 의존
   - 사용자 검색 의도 충족을 위한 최적화

5. **Dashboard**: 데이터 시각화 및 요약
   - Charts, Cards, Filters, Metrics 등 조합
   - 복잡한 데이터 처리 및 시각화
   - 특정 비즈니스 인텔리전스 요구에 특화
   - 도메인별 데이터 모델에 의존

## 6. 경계 사례 분석

일부 컴포넌트는 계층 간 경계에 위치할 수 있습니다. 이러한 경우, 컴포넌트의 현재 구현과 사용 맥락을 고려하여 분류합니다.

### 6.1 경계 사례: DatePicker

**분석**:
- 다양한 프리미티브 조합 (Input, Button, Calendar 등)
- 날짜 선택 및 조작 로직
- 범용성 있는 날짜 선택 기능
- 날짜 형식 및 검증 로직

**결론**: 기본 DatePicker는 **컴파운드 컴포넌트**입니다. 그러나 날짜 범위 선택, 예약 관련 규칙, 업무일 계산 등 특정 비즈니스 로직이 추가되면 **패턴**으로 진화할 수 있습니다.

### 6.2 경계 사례: Form

**분석**:
- 여러 입력 요소 그룹화
- 폼 상태 관리 및 제출 처리
- 유효성 검사 및 오류 처리
- 데이터 모델 의존성

**결론**: 
- **기본 Form**: 단순히 입력 요소를 그룹화하는 기본 Form은 **컴파운드 컴포넌트**
- **특화된 Form**: 복잡한 유효성 검사, 특정 데이터 모델, 서버 통신 등이 통합된 Form은 **패턴 컴포넌트**

### 6.3 경계 사례: 헬퍼 텍스트가 있는 Input

**분석**:
- 인풋 필드와 헬퍼/에러 텍스트의 결합
- 서로 다른 책임을 가진 요소들의 조합 (입력 처리와 정보 표시)
- 사용자 인터페이스에서는 자주 함께 사용됨

**결론**:
- **개념적 분류**: 엄밀한 의미에서 이는 **컴파운드 컴포넌트**입니다. 서로 다른 책임을 가진 요소들의 조합이기 때문입니다.
- **실용적 접근**: 개발자 경험을 위해 `helperText` 속성을 가진 단일 컴포넌트로 제공할 수도 있지만, 이는 개념적으로 이미 컴파운드로 진화한 것입니다.
- **권장 구현**: 프리미티브 컴포넌트(`Input`, `HelperText`)와 컴파운드 컴포넌트(`InputField`) 모두 제공하는 것이 이상적입니다.

```jsx
// 프리미티브 컴포넌트 사용
<div>
  <Input placeholder="이메일 입력" />
  <HelperText>회사 이메일을 입력해주세요.</HelperText>
</div>

// 컴파운드 컴포넌트 사용
<InputField
  placeholder="이메일 입력"
  helperText="회사 이메일을 입력해주세요."
/>
```
## 7. 상태와 변형에 대한 추가 고려사항

컴포넌트 분류 시 상태(states)와 변형(variants)의 존재가 분류 기준에 어떤 영향을 미치는지 이해하는 것이 중요합니다.

### 7.1 상태와 변형이 컴포넌트 분류에 미치는 영향

컴포넌트가 다양한 상태나 변형을 가진다고 해서 반드시 상위 계층으로 분류되지는 않습니다. 중요한 것은 컴포넌트의 구조적 분해 가능성과 기능적 단일성입니다.

**프리미티브 컴포넌트의 상태와 변형**:
- 프리미티브 컴포넌트도 다양한 상태(disabled, focused, error 등)와 변형(outlined, filled 등)을 가질 수 있음
- 이러한 상태와 변형은 컴포넌트의 **속성(props)**으로 제어됨
- 상태와 변형이 있어도 컴포넌트의 구조적 분해 불가능성이 유지된다면 여전히 프리미티브임

예시: 다양한 상태와 변형을 가진 버튼
```jsx
<Button 
  variant="outlined"  // 변형
  size="large"        // 변형
  state="loading"     // 상태
  disabled={true}     // 상태
/>
```

### 7.2 프리미티브와 컴파운드의 구분 재정립

인풋 컴포넌트 예시를 통해 프리미티브와 컴파운드의 구분을 더 명확히 할 수 있습니다:

1. **구조적 분해 가능성**: 컴포넌트가 의미 있는 더 작은 UI 요소로 분해될 수 있는가?
   - 인풋 자체는 분해할 수 없지만, 인풋+헬퍼텍스트는 두 개의 별도 요소로 분해 가능
   - 따라서 인풋은 프리미티브이지만, 인풋+헬퍼텍스트는 컴파운드

2. **기능적 단일성**: 컴포넌트가 단일 기능 카테고리에 속하는가?
   - "단일 기능"은 좁은 용도가 아닌 기능 카테고리를 의미함
   - 인풋의 "사용자 입력 처리"라는 기능은 다양한 입력 유형(텍스트, 숫자 등)과 상태(읽기 전용, 오류 등)를 포함하는 카테고리임

### 7.3 프리미티브 컴포넌트의 용도 다양성

프리미티브 컴포넌트는 다양한 용도로 사용될 수 있으며, 이는 프리미티브 분류와 충돌하지 않습니다:

```jsx
// 다양한 용도의 인풋 (모두 프리미티브)
<Input type="text" />            // 텍스트 입력
<Input type="number" />          // 숫자 입력
<Input type="password" />        // 비밀번호 입력
<Input readOnly value="123" />   // 읽기 전용 값 표시
<Input disabled />               // 비활성화된 입력 필드
```

### 7.4 헬퍼 텍스트와 인풋 필드 - 명확한 접근법

인풋 필드와 헬퍼 텍스트의 관계에 대한 명확한 결론은 다음과 같습니다:

1. **개념적 명확성**: 인풋과 헬퍼 텍스트는 서로 다른 책임을 가진 별개의 UI 요소입니다.
   - 인풋: 사용자 입력 처리
   - 헬퍼 텍스트: 부가 정보 표시

2. **올바른 계층 구조**: 이 두 요소를 결합한 컴포넌트는 **컴파운드 컴포넌트**로 분류되어야 합니다.
   ```jsx
   // 명확한 컴파운드 구조
   <FormField>
     <Input placeholder="이메일 입력" />
     <HelperText>회사 이메일을 입력해주세요.</HelperText>
   </FormField>
   ```

3. **실용적 접근**: 개발자 경험을 위해 helperText 속성을 가진 단일 컴포넌트를 제공하는 것은 편리하지만, 이는 이미 개념적으로 프리미티브가 아닌 컴파운드 컴포넌트입니다.
   ```jsx
   // 편의성을 위한 API이지만, 이는 컴파운드 컴포넌트임
   <InputField
     placeholder="이메일 입력"
     helperText="회사 이메일을 입력해주세요."
   />
   ```

4. **권장 접근법**: 컴포넌트 계층 구조의 명확성을 유지하기 위해, 인풋과 헬퍼 텍스트는 별도의 프리미티브로 유지하고, 이들을 결합한 것은 컴파운드로 분류하는 것이 바람직합니다.# 디자인 시스템 컴포넌트 계층 구조: 명확한 구분 기준


## 8. 실용적 적용 지침

컴포넌트 분류는 이론적 구분뿐 아니라 실용적 관점에서도 접근해야 합니다.

### 8.1 팀 합의

- 명확한 기준을 문서화하고 팀 전체가 이해
- 애매한 사례는 팀 논의를 통해 결정
- 결정 사항을 문서화하여 지속적인 일관성 유지

### 8.2 점진적 진화 허용

- 컴포넌트는 시간에 따라 진화할 수 있음을 인정
- 처음에는 컴파운드로 시작했지만 기능 추가로 패턴으로 발전할 수 있음
- 발전 과정을 문서화하고 필요시 재분류

### 8.3 중간 카테고리 고려

필요한 경우, "Advanced Components"와 같은 중간 카테고리를 도입하여 컴파운드와 패턴 사이의 애매한 컴포넌트를 분류할 수 있습니다.

### 8.4 일관성 유지

- 컴포넌트 분류 결정은 디자인 시스템 전체에 일관되게 적용
- 유사한 컴포넌트는 유사한 방식으로 분류
- 예외를 만들 경우 그 이유를 명확히 문서화

### 8.5 개발자 경험과 구조적 명확성 균형

개발자 경험(DX)과 구조적 명확성 사이의 균형을 고려합니다:

- **구조적 명확성 우선**: 컴포넌트의 개념적 분류는 구조적 관점에서 명확하게 유지
- **개발자 경험 고려**: API는 사용하기 쉽고 직관적이게 설계
- **문서화로 연결**: 실제 사용 패턴과 개념적 구조 간 차이가 있을 경우 문서에 명확히 설명

예를 들어, `InputField`와 같은 컴파운드 컴포넌트를 제공할 때:

```jsx
// 컴파운드 컴포넌트로 문서화하되, 편리한 API 제공
<InputField
  label="이메일"
  placeholder="이메일 입력"
  helperText="회사 이메일을 입력해주세요."
  error={!isValid}
  errorText="유효한 이메일 형식이 아닙니다."
/>
```

## 9. 결론

프리미티브, 컴파운드, 패턴의 명확한 구분은 디자인 시스템의 구조와 유지보수성을 향상시킵니다. 이 문서에서 제공한 정의, 구분 기준, 및 예시를 통해 Lumir Design System의 컴포넌트를 일관되게 분류하고 개발할 수 있습니다.

컴포넌트 계층 구조의 핵심 원칙은 다음과 같습니다:

1. **구조적 분해 가능성**: 컴포넌트가 더 작은 의미 있는 UI 컴포넌트로 분해되는지 여부
2. **기능적 단일성**: 컴포넌트가 단일 기능 카테고리에 속하는지 여부
3. **맥락 독립성**: 컴포넌트가 특정 비즈니스 로직이나 도메인에 독립적인지 여부

이러한 원칙을 적용하면 컴포넌트 분류의 일관성을 유지하고, 디자인 시스템을 효과적으로 구축할 수 있습니다.

명확한 구분 기준을 가지고 있더라도, 컴포넌트 분류는 절대적이기보다 상대적이며 컴포넌트의 진화에 따라 변화할 수 있습니다. 중요한 것은 팀 내에서 일관된 이해와 합의를 바탕으로 컴포넌트를 개발하고 문서화하는 것입니다.
